package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"strconv"
)

func main() {
	if err := _main(); err != nil {
		log.Printf("%s", err)
		os.Exit(1)
	}
}

func _main() error {
	var kinds = []string{
		"Invalid",
		"Int",
		"Float",
		"String",
		"Boolean",
		"Enum",
		"List",
		"Object",
		"Variable",
		"Null",
	}

	if err := genKinds(kinds, "model/kinds.go"); err != nil {
		return err
	}
	return nil
}

func genKinds(kinds []string, dstfn string) error {
	var buf bytes.Buffer

	buf.WriteString("package model")
	buf.WriteString("\n\n// Auto-generated by internal/cmd/genkinds/genkinds.go. DO NOT EDIT")
	buf.WriteString("\n\nimport (")
	for _, path := range []string{"encoding/json", "strconv"} {
		buf.WriteString("\n")
		buf.WriteString(strconv.Quote(path))
	}
	buf.WriteString("\n")
	for _, path := range []string{"github.com/pkg/errors"} {
		buf.WriteString("\n")
		buf.WriteString(strconv.Quote(path))
	}
	buf.WriteString("\n)")
	buf.WriteString("\n\ntype Kind int")
	buf.WriteString("\n\nconst (")
	for i, kind := range kinds {
		buf.WriteString("\n")
		buf.WriteString(kind)
		buf.WriteString("Kind")
		if i == 0 {
			buf.WriteString(" Kind = iota")
		}
	}
	buf.WriteString("\n)")

	buf.WriteString("\n\nfunc (k Kind) MarshalJSON() ([]byte, error) {")
	buf.WriteString("\nreturn []byte(strconv.Quote(k.String())), nil")
	buf.WriteString("\n}")

	buf.WriteString("\n\nfunc (k *Kind) UnmarshalJSON(b []byte) error {")
	buf.WriteString("\nvar s string")
	buf.WriteString("\nif err := json.Unmarshal(b, &s); err != nil {")
	buf.WriteString("\nreturn errors.Wrap(err, `failed to unmarshal string`)")
	buf.WriteString("\n}")
	buf.WriteString("\nswitch s {")
	for _, kind := range kinds {
		switch kind {
		case "Invalid", "Max":
			continue
		}
		buf.WriteString("\ncase \"")
		buf.WriteString(kind)
		buf.WriteString("\":")
		buf.WriteString("\n*k = ")
		buf.WriteString(kind)
		buf.WriteString("Kind")
		buf.WriteString("\nreturn nil")
	}
	buf.WriteString("\n}")
	buf.WriteString("\nreturn errors.Errorf(\"invalid kind in unmarshal: %s\", s)")
	buf.WriteString("\n}")

	buf.WriteString("\n\nfunc(k Kind) String() string {")
	buf.WriteString("\nswitch k {")
	for _, kind := range kinds {
		switch kind {
		case "Invalid", "Max":
			continue
		}
		buf.WriteString("\ncase ")
		buf.WriteString(kind)
		buf.WriteString("Kind:")
		buf.WriteString("\nreturn ")
		buf.WriteString(strconv.Quote(kind))
	}
	buf.WriteString("\n}")
	buf.WriteString("\nreturn \"Invalid\"")
	buf.WriteString("\n}")

	b, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Printf("%s\n", buf.Bytes())
		return err
	}

	f, err := os.Create(dstfn)
	if err != nil {
		return err
	}
	defer f.Close()
	f.Write(b)
	return nil
}
