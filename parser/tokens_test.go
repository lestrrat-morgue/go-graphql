// Auto-generated by internal/cmd/gentokens. DO NOT EDIT

package parser_test

import (
	"github.com/lestrrat/go-graphql/parser"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestTokenTypeString(t *testing.T) {
	t.Run("ILLEGAL", func(t *testing.T) {
		tok := parser.ILLEGAL
		if !assert.Equal(t, "ILLEGAL", tok.String(), "strings match") {
			return
		}
	})
	t.Run("IGNORABLE", func(t *testing.T) {
		tok := parser.IGNORABLE
		if !assert.Equal(t, "IGNORABLE", tok.String(), "strings match") {
			return
		}
	})
	t.Run("EOF", func(t *testing.T) {
		tok := parser.EOF
		if !assert.Equal(t, "EOF", tok.String(), "strings match") {
			return
		}
	})
	t.Run("BANG", func(t *testing.T) {
		tok := parser.BANG
		if !assert.Equal(t, "BANG", tok.String(), "strings match") {
			return
		}
	})
	t.Run("DOLLAR", func(t *testing.T) {
		tok := parser.DOLLAR
		if !assert.Equal(t, "DOLLAR", tok.String(), "strings match") {
			return
		}
	})
	t.Run("PAREN_L", func(t *testing.T) {
		tok := parser.PAREN_L
		if !assert.Equal(t, "PAREN_L", tok.String(), "strings match") {
			return
		}
	})
	t.Run("PAREN_R", func(t *testing.T) {
		tok := parser.PAREN_R
		if !assert.Equal(t, "PAREN_R", tok.String(), "strings match") {
			return
		}
	})
	t.Run("SPREAD", func(t *testing.T) {
		tok := parser.SPREAD
		if !assert.Equal(t, "SPREAD", tok.String(), "strings match") {
			return
		}
	})
	t.Run("COLON", func(t *testing.T) {
		tok := parser.COLON
		if !assert.Equal(t, "COLON", tok.String(), "strings match") {
			return
		}
	})
	t.Run("EQUALS", func(t *testing.T) {
		tok := parser.EQUALS
		if !assert.Equal(t, "EQUALS", tok.String(), "strings match") {
			return
		}
	})
	t.Run("AT", func(t *testing.T) {
		tok := parser.AT
		if !assert.Equal(t, "AT", tok.String(), "strings match") {
			return
		}
	})
	t.Run("BRACKET_L", func(t *testing.T) {
		tok := parser.BRACKET_L
		if !assert.Equal(t, "BRACKET_L", tok.String(), "strings match") {
			return
		}
	})
	t.Run("BRACKET_R", func(t *testing.T) {
		tok := parser.BRACKET_R
		if !assert.Equal(t, "BRACKET_R", tok.String(), "strings match") {
			return
		}
	})
	t.Run("BRACE_L", func(t *testing.T) {
		tok := parser.BRACE_L
		if !assert.Equal(t, "BRACE_L", tok.String(), "strings match") {
			return
		}
	})
	t.Run("PIPE", func(t *testing.T) {
		tok := parser.PIPE
		if !assert.Equal(t, "PIPE", tok.String(), "strings match") {
			return
		}
	})
	t.Run("BRACE_R", func(t *testing.T) {
		tok := parser.BRACE_R
		if !assert.Equal(t, "BRACE_R", tok.String(), "strings match") {
			return
		}
	})
	t.Run("NAME", func(t *testing.T) {
		tok := parser.NAME
		if !assert.Equal(t, "NAME", tok.String(), "strings match") {
			return
		}
	})
	t.Run("INT", func(t *testing.T) {
		tok := parser.INT
		if !assert.Equal(t, "INT", tok.String(), "strings match") {
			return
		}
	})
	t.Run("FLOAT", func(t *testing.T) {
		tok := parser.FLOAT
		if !assert.Equal(t, "FLOAT", tok.String(), "strings match") {
			return
		}
	})
	t.Run("STRING", func(t *testing.T) {
		tok := parser.STRING
		if !assert.Equal(t, "STRING", tok.String(), "strings match") {
			return
		}
	})
	t.Run("TokenTypeMax", func(t *testing.T) {
		tok := parser.TokenTypeMax
		if !assert.Equal(t, "TokenTypeMax", tok.String(), "strings match") {
			return
		}
	})
}
